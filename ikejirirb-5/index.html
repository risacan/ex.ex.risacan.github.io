<!doctype>
<html lang="ja">
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>ikejirirb | risacan.github.io</title>

<title>risacan.github.io</title>
<script src="/js/script.js"></script>
<link rel="stylesheet" href="/css/style.css">
<link rel="shortcut icon" href="/images/profile.png">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-84656331-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-84656331-1');
</script>

<meta name="description" content="やったこと 第5章   memo p117  オブジェクトはそのクラスよりもそのふるまいによって定義される   p118  物理世界における美とおなじいように、アプリにおけるオブジェクトの型は、見るものの目にやどります。オブジェクトの使い手はそのクラスを気にする必要はなく、気にするべきでもない 重要なのはオブジェクトが何で有るかではなく、 何をするか   p119  クラスをまたいだ型を認識するこ">
<meta property="og:type" content="article">
<meta property="og:title" content="ikejirirb">
<meta property="og:url" content="http://risacan.github.io/ikejirirb-5/index.html">
<meta property="og:site_name" content="risacan.github.io">
<meta property="og:description" content="やったこと 第5章   memo p117  オブジェクトはそのクラスよりもそのふるまいによって定義される   p118  物理世界における美とおなじいように、アプリにおけるオブジェクトの型は、見るものの目にやどります。オブジェクトの使い手はそのクラスを気にする必要はなく、気にするべきでもない 重要なのはオブジェクトが何で有るかではなく、 何をするか   p119  クラスをまたいだ型を認識するこ">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://assets-cdn.github.com/images/icons/emoji/unicode/1f645.png?v8">
<meta property="og:image" content="https://assets-cdn.github.com/images/icons/emoji/unicode/1f414.png?v8">
<meta property="og:image" content="https://assets-cdn.github.com/images/icons/emoji/unicode/1f693.png?v8">
<meta property="og:image" content="https://assets-cdn.github.com/images/icons/emoji/unicode/1f46e.png?v8">
<meta property="og:image" content="https://assets-cdn.github.com/images/icons/emoji/unicode/1f694.png?v8">
<meta property="og:updated_time" content="2017-04-27T21:06:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ikejirirb">
<meta name="twitter:description" content="やったこと 第5章   memo p117  オブジェクトはそのクラスよりもそのふるまいによって定義される   p118  物理世界における美とおなじいように、アプリにおけるオブジェクトの型は、見るものの目にやどります。オブジェクトの使い手はそのクラスを気にする必要はなく、気にするべきでもない 重要なのはオブジェクトが何で有るかではなく、 何をするか   p119  クラスをまたいだ型を認識するこ">
<meta name="twitter:image" content="https://assets-cdn.github.com/images/icons/emoji/unicode/1f645.png?v8">
<meta name="twitter:creator" content="@_risacan_">
<link rel="stylesheet" href="https://csshake.surge.sh/csshake.min.css">

<body class="background courier">
  <header>
  <div class="tc pv4">
    <a href=""https://risacan.github.io"><img src="/images/profile.png" class="pa1 h3 w3 shake-rotate" alt="avatar"></a>
    <h1 class="f5 f4-ns fw6 mid-gray">risacan.github.io</h1>
    <h2 class="f6 gray fw2 ttu tracked"></h2>
  </div>
</header>

  <nav class="db dt-l w-100 border-box">
  <div class="tc mb3">
    <a href="/about" title="📛" class="link dim gray f6 f5-ns dib m3">📛</a>
    <a href="/" title="📝" class="link dim gray f6 f5-ns dib m3">📝</a>
    <a href="/works" title="💎" class="link dim gray f6 f5-ns dib m3">💎</a>
  </div>
</nav>

  <main class="mw7 pl3 pr3 pb3 mb3 center"><article class="pl3 pr3">
  <h1 class="f3 mb0">IKEJIRIRB</h1>
  
    <span class="f6 blue">2017-04-27 21:06:52 Thursday</span>
  
  <div class="article-body"><h1 id="やったこと"><a href="#やったこと" class="headerlink" title="やったこと"></a>やったこと</h1><ul>
<li>第5章 </li>
</ul>
<h1 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h1><ul>
<li><p>p117</p>
<ul>
<li>オブジェクトはそのクラスよりもそのふるまいによって定義される</li>
</ul>
</li>
<li><p>p118</p>
<ul>
<li>物理世界における美とおなじいように、アプリにおけるオブジェクトの型は、見るものの目にやどります。オブジェクトの使い手はそのクラスを気にする必要はなく、気にするべきでもない</li>
<li>重要なのはオブジェクトが何で有るかではなく、 <strong>何をするか</strong></li>
</ul>
</li>
<li><p>p119</p>
<ul>
<li>クラスをまたいだ型を認識すること、パブリックインターフェースを ~略~ 意図をもって入念につくること</li>
</ul>
</li>
<li><p>p122</p>
<ul>
<li>心の奥底では、引数はMechanicであるとおもってしまっている<ul>
<li>おもってしまっている時点で特定のクラスを期待してる</li>
<li>クラスは気にしてはいけないものなので no good <img class="github-emoji" style="vertical-align:text-bottom;height:16px;width:16px" title="no_good" alt="no_good" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f645.png?v8" height="20" width="20"> </li>
</ul>
</li>
</ul>
</li>
<li><p>p123</p>
<ul>
<li>シーケンス図はそれが描いているコードよりも常にかんたんなものでなければならない</li>
</ul>
</li>
<li><p>p124</p>
<ul>
<li>prepare メソッドは旅行の準備をすること(prepare)を望みます。その引数も旅行の準備に協力しようとやってきます。prepareが引数のその動作を単に信頼すれば、設計はより簡潔になるでしょう。</li>
</ul>
</li>
<li><p>p126</p>
<ul>
<li>Prepareerと相互作用するオブジェクトに必要なのは、それがPreparerのインターフェースを実装していると信頼すること <strong>だけ</strong></li>
</ul>
</li>
<li><p>p128</p>
<ul>
<li>ポリモーフィズム</li>
</ul>
</li>
<li><p>p129</p>
<ul>
<li>ダックタイプの実装は比較的簡単だが、ダックタイプが必要であることに気づくことと、そのインターフェースを抽象化することが難しい</li>
<li>隠れたダック <img class="github-emoji" style="vertical-align:text-bottom;height:16px;width:16px" title="chicken" alt="chicken" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f414.png?v8" height="20" width="20"> を認識する<ul>
<li><img class="github-emoji" style="vertical-align:text-bottom;height:16px;width:16px" title="police_car" alt="police_car" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f693.png?v8" height="20" width="20"> <img class="github-emoji" style="vertical-align:text-bottom;height:16px;width:16px" title="cop" alt="cop" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f46e.png?v8" height="20" width="20"> <img class="github-emoji" style="vertical-align:text-bottom;height:16px;width:16px" title="oncoming_police_car" alt="oncoming_police_car" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f694.png?v8" height="20" width="20"> </li>
<li>クラスで分岐するcase文</li>
<li>kind_of?とis_a?</li>
<li>responds_to&gt;</li>
</ul>
</li>
</ul>
</li>
<li><p>p132</p>
<ul>
<li>ダックを信頼する</li>
</ul>
</li>
<li><p>p135</p>
<ul>
<li>動的型付けを恐れるプログラマーは、コード内でオブジェクトのクラスを検査する傾向にある。この検査こそ、まさに動的型付けの力を削ぐものであり、ダックタイプの利用を不可能にしているのです</li>
<li>静的型付けを信じるプログラマーは、型エラーでfailすることを理由に型検査が必要だ！っていうけど、この問題の唯一の解決策は型検査を全部とりのぞくこと</li>
</ul>
</li>
<li><p>p136</p>
<ul>
<li>静的型付けのメリット<pre><code>  * コンパイラがコンパイル時に型エラーを発見してくれる
      * コンパイラが型を検査しない限り、実行時の型エラーがおこる場合
  * 可視化された型情報は文書の役割を果たしてくれる
      * 方がなければプログラマーがコードを理解できない場合
  * コンパイルされたコードは最適化され高速に動作する 
      * 最適化がないとアプリの動作がおそすぎる場合
</code></pre></li>
<li>動的型付けのメリット<ul>
<li>コードは逐次実行され動的に読み込まれるため、コンパイル/makeのサイクルがない<ul>
<li>アプリ全体の開発はコンパイル・makeのサイクルがない方が拘束な場合</li>
</ul>
</li>
<li>ソースコードは明示的な型情報を含まない<ul>
<li>型宣言がコードに含まれないときのほうがプログラマーにとって理解するのが簡単な場合</li>
</ul>
</li>
<li>メタプログラミングより簡単<ul>
<li>メタプログラミングが言語機能として必要な場合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>メタプログラミングRuby 読まねば</p>
</div>
  
    <a href="https://twitter.com/intent/tweet?text=ikejirirb%20|%20risacan.github.io&url=" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
  
</article>

</main>
  <footer>
  <div class="tc pb3">
    <a class="link dim gray f6 f5-ns dib mr3" href="https://twitter.com/_risacan_">@risacan</a>
  </div>
</footer>

</body>
</html>